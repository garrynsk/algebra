
package algebra

import algebra.stones.SemigroupComponent
import annotation.implicitNotFound

/**
    A semigroup is a set A together with a binary operation combine (that is, a function combine: A x A -> A) 
    that satisfies the associative property. So a semigroup is a semicategory with one object.
    
    - Instances are required to satisfy the semicategory law:

        (associativity) if f : a → b, g : b → c and h : c → d then h <<< (g <<< f) = (h <<< g) <<< f, and

    - And the additional law:

        (associativity) (x <:> y) <:> z = x <:> (y <:> z)
*/

@implicitNotFound("A value of type Semigroup[${A}] cannot be found")
trait Semigroup[A] extends SemigroupComponent[A]

object Semigroup {

    def apply[A](implicit instance: Semigroup[A]): Semigroup[A] = instance

    object Ops {

        implicit class toSemigroupObject[A](self: A)(implicit tc: Semigroup[A]) extends SemigroupComponent.Ops[A] { 

            override def typeClassInstance = tc
            override def target = self
            
        }
    }
}


/**
    Semigroups have the ability to arbitrarily partition your data and combine it.
    For ex. Being a Semigroup means you can combine adjacent Logs into an aggregate Log in any order you want. 
    You could split up the work of combining Logs across multiple threads and 
    know that it is still 100% safe to combine the individual thread’s results into a final result.

    Carrying on with the idea of Logs, consider a remote logging service that accepts Logs 
    from your various servers and aggregates them down into something you can do reporting on. 
    If we still have a Log type that is a Semigroup, we have a lot of freedom in how we proceed.
    For example, when a Log is generated by one of your servers, it could send it immediately, 
    or combine some number of Logs before sending them.

    https://blog.axosoft.com/monoids-practical-category-theory/
*/